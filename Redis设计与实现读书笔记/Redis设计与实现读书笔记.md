# Note

## 第一部分 数据结构与对象

### 第二章 简单动态字符串

#### 简介

C字符串只会作为字面量用在一些不需要对值修改的地方，如日志打印

需要修改的字符串值：SDS

#### SDS定义

![image-20201029171025078](Redis设计与实现读书笔记.assets\image-20201029171025078.png)

可以直接重用C的字符函数

#### 与C字符串区别

- 常数复杂度获取字符串长度，自身记录了长度
- 杜绝缓冲区溢出，空间不足时自动扩大空间
- 减少重分配次数
    - 分配策略
        - 需要扩展时 会分配额外的未使用空间
        - 空间足够时不会进行内存重分配
    - 惰性空间释放
        - 使用free记录未使用空间，以备之后使用，不直接释放
        - 必要时也有API释放
- 二进制安全
    - 可以保存任意二进制数据
    - 因为不以空来作为结束标志
- 兼容部分C字符串函数
    - 可以使用<string.h>中所有的函数

### 第三章 链表

#### 基本实现

<img src="Redis设计与实现读书笔记.assets\image-20201029182514015.png" alt="image-20201029182514015" style="zoom:80%;" />

<img src="Redis设计与实现读书笔记.assets\image-20201029182527137.png" alt="image-20201029182527137" style="zoom:80%;" />

(void*)实现多态

#### 用途

链表键；发布与订阅；慢查询；监视器

### 第四章 字典（哈希）

#### 数据结构

<img src="Redis设计与实现读书笔记.assets\image-20201030092219475.png" alt="image-20201030092219475" style="zoom:80%;" />





<img src="D:\huangchenhong\note\java_learn\Redis设计与实现读书笔记\Redis设计与实现读书笔记.assets\image-20201030092235896.png" alt="image-20201030092235896" style="zoom:80%;" />

#### 冲突解决

相同索引处的键通过*next以链表形式处理，操作时为头插

#### 哈希算法

MurmurHash算法

#### rehash

- 以ht[1]为副本进行转移，转移过程和HashMap类似
- 为渐进式rehash，一边rehash一边执行查找插入等操作

### 第五章 有序集合（跳跃表）



### 第六章 整数集合

#### 定义

<img src="D:\huangchenhong\note\java_learn\Redis设计与实现读书笔记\Redis设计与实现读书笔记.assets\image-20201030094619548.png" alt="image-20201030094619548" style="zoom:80%;" />

- 各项有序排列
- contents数组的真正类型取决于encoding的值（INTSET_ENC_INT16，INTSET_ENC_INT32...)

#### 升级

扩宽数组底层空间为类型最大元素的数组

无法降级

### 第七章 压缩列表

#### 构成

一系列特殊编码的连续内存块组成的顺序型数据结构

<img src="Redis设计与实现读书笔记.assets\image-20201030101107484.png" alt="image-20201030101107484" style="zoom:80%;" />

#### 节点的构成

<img src="Redis设计与实现读书笔记.assets\image-20201030101230331.png" alt="image-20201030101230331" style="zoom:80%;" />

- 前一节点的长度（以此可以从链表尾节点遍历至头节点，即当前头地址-前一节点长度）
- 数据类型及长度
- 可以是字节数组或者整数

#### 连锁更新

增加和删除时都有可能发生，概率较低，性能损失较大

### 第八章 对象

Redis并不直接使用之前的数据结构来实现键值对数据库，而是基于这些键值对创建了一个对象系统

#### 对象的类型和编码

新创建键值对时，至少创建了一个键对象和值对象

<img src="Redis设计与实现读书笔记.assets\image-20201030102844055.png" alt="image-20201030102844055" style="zoom:80%;" />

##### 类型

<img src="Redis设计与实现读书笔记.assets\image-20201030103127468.png" alt="image-20201030103127468" style="zoom:67%;" />

字符串键：值为字符串

列表键：值为列表

##### 编码和底层实现

ptr指向数据结构，encoding表示对象所使用的编码，增加了灵活性

#### 字符串对象

编码可以是int，raw，embstr

- 编码可能发生转换，比如向Int后添加字符串

#### 列表对象

编码可以是ziplist，linkedlist

- ziplist为压缩列表，每个entry保存列表元素
- linkedlist为双端列表，每个Node保存了一个字符串对象

#### 哈希对象

编码可以是ziplist或hashtable

- 采用ziplist，使用压缩列表，键值紧挨
- 采用hashtable，采用字典，键值都为字符串对象

#### 集合对象

编码可以是intset或hashtable

- 采用intset，采用整数集合
- 采用hashtable，采用字典，值全部设置为NULL

编码转换

#### 有序集合对象

编码可以是ziplist或者skiplist

- 前者压缩列表
- 后者为zset，包含一个字典和跳跃表：同时保留O(1)取分值与O(N)范围查找的特性

#### 类型检查与命令多态

- 检查对象的Type属性是否为指定的对象属性
- 根据对象的编码来确定使用哪种数据结构的方法

#### 内存回收

引用计数，适当时候将对象回收

#### 对象共享

键的值指针指向同一个对象

引用计数加一

例子：一部分整数型字符串对象已经建立好，服务器会使用共享对象

#### 对象的空转时长

内存使用超过上限时会回收内存

## 第二部分 单机数据库的实现

### 第九章 数据库

#### 服务器中的数据库

所有的数据库都保存在redisServer结构的db数组中

```c
struct redisServer {
    redisDb *db;
    int dbnum;
    struct saveparam *saveparams; //保存选项数组
}
```

默认情况下dbnum = 16，即配置16个数据库

- 改变redisClient.db指针，改变工作数据库

#### 数据库键空间

```c
struct redisDb {
    ...
    Dict *dict;
    Dict *expires;
    ...
}
```

Redis是键值对数据库服务器，每个数据库中的dict字典保存了该数据库中的所有键值对

#### 增删改查操作



#### 维护操作

- 更新LRU时间，可通过OBJECT idletime查看
- ...

#### 设置键的生存时间或过期时间

##### 相关命令

EXPIRE PEXPIRE 设置生存时间

EXPIREAT PEXPIREAT 设置过期时间

TTL PTTL 返回一个键的剩余存活时间

##### 过期字典

expires字典保存了所有键的过期时间

- 移除过期时间
- 计算并返回生存时间
- 判断是否过期：先判断键是否存在于过期字典，如存在就取得过期时间；然后检查UNIX时间戳是否大于该过期时间

#### 过期键删除策略

- 定时删除（主动）：创建一个定时器，时间一到立即删除
    - 优点：内存友好，尽快删除过期键；CPU不友好，在不缺内存请求较多的时候CPU会浪费在定时器上
- 惰性删除（被动）：每次取出键时才做过期检查，发现过期删除
    - 优点：CPU友好，内存不友好；有些键可能永远不会删除
- 定期删除（主动）：前两种策略的折中

#### Redis的过期键处理

惰性删除+定期删除

- 惰性删除：所有数据库读写操作Redis命令在执行前都会调用expireIfNeeded对输入键进行检查
- 定期删除：分多次遍历数据库，从expires字典随机检查一部分键

#### AOF RDB 复制功能对过期键的处理



#### 数据库通知

关注某个键做了什么：“键空间通知”

关注某个命令被谁执行了：“键事件通知”

​	

### 第十章 RDB持久化

#### 含义

Redis为内存数据库，为了防止数据库中因服务器进程异常而状态永久丢失

RDB持久化功能将数据库状态转移到一个经过压缩的二进制文件中，通过该文件可以还原成数据库生成该文件时的状态

#### RDB文件创建与载入

##### 创建

SAVE 阻塞服务器进程创建

BGSAVE 派生子进程创建

##### 载入

服务器启动时发现有RDB文件自动载入

（优先使用AOF载入）

载入时服务器也处于阻塞状态

##### 自动间隔保存

根据save命令将设置加入saveparams数组

#### RDB文件结构

![image-20201101092134676](Redis设计与实现读书笔记.assets\image-20201101092134676.png)



EOF：键值对输入完毕

check_sum：校验和，检查出错或损害情况

### 第十一章 AOF持久化

#### 方式

保存服务器执行了的写命令

#### 具体实现

- 命令追加：将发送的写命令追加到缓冲区的末尾
- 写入与同步：定时任务将缓冲区中的内容写入或保存至AOF文件

#### 载入与数据还原

创建伪客户端执行AOF文件保存的命令

#### 重写

- 防止AOF文件的冗余，生成新的AOF文件只包含还原当前数据库状态所需的命令

- 避免服务进程阻塞，创建子进程进行重写，同时设置重写缓冲区应对重写时发生的修改



### 第十二章 事件

Redis服务器是事件驱动程序

分为时间事件和文件事件



### 第十三章 客户端





### 第十四章 服务端

#### 命令执行的请求过程

1. 客户端键入命令，转为协议格式发送，连接到服务器套接字并发送给服务器
2. 服务器保存进缓存区，分析并提取参数，使用命令执行器执行
    1. 查找命令类型
    2. 检查身份，参数准确性等
    3. 调用命令的实现函数
    4. 后续工作，日志，AOF持久化等等
3. 将结果发回客户端，共用户读取

#### ServerCron函数

- 更新LRU时钟
- 更新服务器每秒执行命令个数
- ...

## 第三部分 多机数据库的实现

### 第十五章 复制

#### 含义

SLAVEOF命令使一个服务器变为另一个主服务器的从服务器，两者的状态将被完全同步

#### 旧版实现

##### 同步

- 从服务器发送SYNC命令
- 主服务器执行BGSAVE，生成RDB文件，同时将之后的写命令存入缓存区
- 从服务器接受RDB文件，和缓冲区所有写命令，更新至相同状态

##### 命令传播

主服务器将自己执行的写命令发给从服务器

#### 新版实现

##### 意义

解决旧版短线重同步时带来的再次发送SYNC命令的问题

具有完整重同步和部分重同步功能

后者发送断线期间主服务器执行了的命令即可

##### 部分重同步的实现

- 复制偏移量：双方同时维护这个量，可以判断当前是否处于一致状态
- 复制积压缓冲区：主服务器维护的一个固定长度FIFO队列，命令传播时同时将命令写入该队列。断线重连后检测偏移量内的命令是否仍在队列中，判断后执行剩余命令发送或是完整重同步
- 服务器运行ID：从服务器保存，当发现前后的主服务器不一样，执行完全重同步。

#### 心跳检测

命令传播阶段，从服务器每秒一次向主服务器发送REPLCONF ACK <replication_offset>（从服务器复制偏移量）

- 检查主从服务器间的网络连接状态
- 辅助实现min-slaves配置项
- 检测写命令丢失

### 第十六章 Sentinel（哨兵）

#### 含义

是Redis高可用性的解决方案

由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主从服务器

当被监视的主服务器下线，自动升级其某个从服务器为主服务器，原其他从服务器成为新主服务器的从服务器。原主服务器恢复时也成为从服务器

#### 启动

类似于正常Redis服务器，换用代码和初始相关数据结构等

### 第十七章 集群

#### 含义

集群通过分片来进行数据共享，并提供复制与转移功能

#### 节点



#### 分片

整个数据库分为一定数量的槽，数据库的每个键都属于其中一个槽，不同的节点一定数量的槽。

#### 重新分片



#### ASK错误 MOVED错误

槽正在转移



### 第十九章 事务

#### 事务的实现

- 事务开始：MULTI，客户端打开REDIS_MULTI标识
- 命令入队：处于事务状态时，非EXEC,DISCARD,WATCH,MULTI的命令会放入事务队列，否则立刻执行
- 执行事务：EXEC命令遍历执行事务队列中的所有命令，将结果一次性返回

#### WATCH命令

##### 含义

乐观锁，在EXEC命令前监视任意数据键，如果发现被修改则拒绝执行事务

##### 原理

- 服务端保存watched_keys字典<键，监视客户端链表>
- 所有修改命令后检测字典里的键是否被修改，若被修改则打开REDIS_DIRTY_CAS标识，表示事务安全性已被破坏
- 服务端根据客户端的REDIS_DIRTY_CAS来判断是否执行事务

#### 事务的ACID

- A（原子性）：不支持回滚，出错也会执行到底

- C（一致性）：

- I（隔离性）：使用的单线程执行命令，所以事务总是以串行运行

- D（持久性)：只有在AOF的appendfsync设置为always才有持久性

    

# 经典面试题











